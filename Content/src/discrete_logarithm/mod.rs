use crate::number_theory::chinese_remainder_theorem;
use crate::prime_factorization::prime_factorize;
use crate::montgomery_mod_mult::Context;
use rand::Rng;
use rug::ops::{Pow, PowAssign};
use rug::{Integer, Assign};
use std::ops::ShrAssign;
use num_traits::PrimInt;

/// Computes (b^e) % m for generic integer types that support required operations.
/// Works with u32, u64, i128, u128, etc.
fn modpow<T>(mut b: T, mut e: u64, m: T) -> T where T: PrimInt + Copy, {
    let mut result = T::one();
    b = b % m;
    while e > 0 {
        if e % 2 == 1 {
            result = result * b % m;
        }
        b = b * b % m;
        e >>= 1;
    }

    result
}

/// Converts the a vector of (Integer, u32) into (u64, u32). throws an error if 
/// one of the values does not fit in a u64.
fn convert_factors_u64(factors: Vec<(Integer, u32)>) -> Result<Vec<(u64, u32)>, String> {
    factors
        .into_iter()
        .map(|(i, exp)| {
            i.to_u64()
                .ok_or_else(|| format!("the prime factor {} is too large for u64", i))
                .map(|val| (val, exp))
        })
        .collect()
}

/// Calculates the product of the prime factors of n, given as a vector of (p, e) tuples.
fn product(factorization: &Vec<(u64, u32)>) -> Integer {
    let mut result = Integer::ONE.clone();
    for (p, e) in factorization {
        result *= Integer::from(*p).pow(e);
    }
    result
}

/// Calculates the order of an element g in (Z/nZ)*
/// Pass it the factors of phi_n, NOT n.
fn find_order(n: &Integer, phi_n: &Integer, g: &Integer, factors: &Vec<(u64, u32)>) -> Integer {
    let mut ord = phi_n.clone();
    let g_inv = Integer::from(g.invert_ref(&n).unwrap());

    let mut p_pow = Integer::new();
    let mut g_inv_pow = Integer::new();
    let mut phi_n_over_p_pow = Integer::new();
    for (p, e) in factors {
        p_pow.assign(p);
        for _ in 0..*e {
            phi_n_over_p_pow.assign(phi_n / &p_pow);
            g_inv_pow.assign(g_inv.pow_mod_ref(&phi_n_over_p_pow, &n).unwrap());
            if g_inv_pow == 1 {
                p_pow *= p;
                ord /= p;
            }
        }
    }
    ord
}

/// Updates a single step of Pollard's rho for discrete log.
fn update(x: &mut Integer, a: &mut u64, b: &mut u64, g: &Integer, h: &Integer, p: &u64, ctx: &mut Context) {
    match ctx.from_montgomery(&*x).mod_u(3) {
        0 => {
            // x = x^2; a = 2a; b = 2b
            ctx.square_mut(x);
            *a *= 2;
            *b *= 2;
        } 1 => {
            // x = x * g; a = a + 1
            *x *= ctx.wrap(g);
            *a += 1;
        } _ => {
            // x = x * h; b = b + 1
            *x *= ctx.wrap(h);
            *b += 1;
        }
    }
    
    *a -= *p * (*a >= *p) as u64;
    *b -= *p * (*b >= *p) as u64;
}

/// Finds x such that g^x = h mod n, assuming a solution exists.
/// Also assumes g has order p, and h is in the subgroup generated by g.
fn pollard_rho_dlog(g: &Integer, h: &Integer, p: &u64, n: &Integer, ctx: &mut Context) -> u64 {
    // println!("pollard's on g = {}, h = {}, n = {} and group order is {}", g, h, n, p);
    if g == h {
        return 1;
    }
    if h == Integer::ONE || *p == 2 {
        return 0;
    }
    if *p == 3 {
       return 2;
    }

    let mut g_m = ctx.to_montgomery(g);
    let mut h_m = ctx.to_montgomery(h);
    let starting_val = ctx.one();
    let limit  = 10 * (*p as f64).sqrt() as i128;
    let mut res_a: i128 = 1;
    let mut res_b: i128 = 0;
    let mut rng = rand::rng();

    loop {
        let mut x1 = starting_val.clone();
        let mut a1: u64 = 0;
        let mut b1: u64 = 0;
        let mut x2 = x1.clone();
        let mut a2: u64 = 0;
        let mut b2: u64 = 0;

        for _ in 0..limit {
            update(&mut x1, &mut a1, &mut b1, &g_m, &h_m, &p, ctx);
            update(&mut x2, &mut a2, &mut b2, &g_m, &h_m, &p, ctx);
            update(&mut x2, &mut a2, &mut b2, &g_m, &h_m, &p, ctx);
            //println!("a1: {}, b1: {}, x1: {}, a2:{}, b2: {}, x2: {}", a1, b1, ctx.from_montgomery(&x1), a2, b2, ctx.from_montgomery(&x2));
            if x1 == x2 {
                break;
            }
        }
        
        //println!("a1: {}, b1: {}, x1: {}, a2:{}, b2: {}, x2: {}", a1, b1, ctx.from_montgomery(&x1), a2, b2, ctx.from_montgomery(&x2));
        //println!("a = {}, b = {}, g = {}, h = {}", res_a, res_b, ctx.from_montgomery(&g_m), ctx.from_montgomery(&h_m));

        // Solve: (a1 - a2) = x * (b2 - b1) mod p
        let mut b = b2 as i128 - b1 as i128;
        b += *p as i128 * (b <  0) as i128;
        if b == 0 || x1 != x2 {
            //println!("bruh.");
            res_a = rng.random_range(1..*p) as i128;
            res_b = rng.random_range(0..*p) as i128;
            g_m.assign(g.pow_mod_ref(&Integer::from(res_a), &n).unwrap());
            h_m.assign(g.pow_mod_ref(&Integer::from(res_b), &n).unwrap());
            h_m *= h;
            h_m %= n;
            if g_m == h_m {
                res_a -= res_b;
                res_a += *p as i128 * (res_a < 0) as i128;
                return res_a as u64;
            }
            if h_m == *Integer::ONE {
                res_b = *p as i128 * (res_b != 0) as i128 - res_b;
                return res_b as u64;
            }
    
            ctx.to_montgomery_mut(&mut g_m);
            ctx.to_montgomery_mut(&mut h_m);
            continue; // Try again
        }

        let mut a = a1 as i128 - a2 as i128;
        a += *p as i128 * (a < 0) as i128;
        a *= modpow(b, p - 2, *p as i128);
        a %= *p as i128;

        res_a *= a;
        res_a %= *p as i128;
        res_a -= res_b;
        res_a += *p as i128 * (res_a < 0) as i128;
        return res_a as u64;
    }
}

/// Calculates the discrete logarithm modulo 2^n.
fn discrete_log_mod_2pow(g: &Integer, h: &Integer, n: u32) -> Option<Integer> {
    // println!("discrete log prime power mod 2pow on g = {}, h = {}, n = 2^{}", g, h, n);
    if n == 1 {
        return Some(Integer::ONE.clone());
    }
    if n == 2 {
        if g == Integer::ONE {
            if h == Integer::ONE {
                return Some(Integer::ONE.clone());
            } else {
                return None;
            }
        } else {
            return Some(Integer::ONE.clone());
        }
    }
    if h == Integer::ONE {
        return Some(Integer::ZERO);
    }
    if g == h {
        return Some(Integer::ONE.clone());
    }

    let m = Integer::from(2).pow(&n);
    let g_is_quad_res = g.is_congruent_2pow(Integer::ONE, 3);
    let h_is_quad_res = h.is_congruent_2pow(Integer::ONE, 3);

    if g_is_quad_res {
        if h_is_quad_res {
            return match discrete_log_prime_power_mod(&2, &n, &m, g, h) {
                Some((val1, _)) => Some(val1),
                None => None,
            };
        } else {
            return None;
        }
    } else {
        if h_is_quad_res {
            return match discrete_log_prime_power_mod(&2, &n, &m,
                &g.clone().square().keep_bits(n), h) {
                None => None,
                Some(val) => Some(2 * val.0),
            };
        } else {
            if h.is_congruent_2pow(&g, 3) {
                let new_h = Integer::from(g * h).keep_bits(n);
                let mut new_g = g.clone().square().keep_bits(n);
                if new_h == *Integer::ONE {
                    let mut ord = 1u32;
                    while new_g != *Integer::ONE {
                        new_g.square_mut();
                        new_g.keep_bits_mut(n);
                        ord *= 2;
                    }
                    return Some(Integer::from(2 * ord - 1)); 
                }
                return match discrete_log_prime_power_mod(&2, &n, &m, &new_g, &new_h) {
                    Some((val1, _)) => Some(2 * val1 - 1),
                    None => None,
                };
            } else {
                return None;
            }
        }
    }
}

/// Solves for the discrete logarithm mod m where m is a power of an odd prime (to guarantee its a cyclic group)
/// And with the additional assumption that the order of g is p^e and a solution exists.
fn discrete_log_prime_power_order(p: &u64, e: &u32, m: &Integer, ctx: &mut Context, mut g: Integer, h: &Integer) -> Integer {
    // println!("discrete log prime power order on g = {}, h = {}, n = {} and group order is {}^{}", g, h, m, p, e);
    if g == *h {
        return Integer::ONE.clone();
    }
    let mut x: Integer = Integer::ZERO.clone();
    let mut p_pow: Vec<Integer> = vec![Integer::from(*p); (*e + 1) as usize];
    p_pow[0].assign(1);
    if p_pow.len() > 2 {
        p_pow[2].assign(p * p);
    }
    for i in 3..=*e as usize {
        let [p_pow_1, p_pow_i_1, p_pow_i] = p_pow.get_disjoint_mut([1, i-1, i]).unwrap();
        p_pow_i.assign(&*p_pow_1 * &*p_pow_i_1);
    }

    //println!("hi");
    let e_minus_1: usize = (e - 1) as usize;
    let gamma = Integer::from(g.pow_mod_ref(&p_pow[e_minus_1], &m).unwrap());
    g.invert_mut(&m).unwrap();  // g = g^-1
    
    //println!("gamma: {}, g^-1: {}", gamma, g);
    let mut h_k = Integer::new();
    for k in 0..*e as usize {
        h_k.assign(g.pow_mod_ref(&x, &m).unwrap());
        h_k *= h;
        h_k.pow_mod_mut(&p_pow[e_minus_1 - k], &m).unwrap();
        //println!("h_k: {}", h_k);
        //println!("result: {}, multiplied with {}", pollard_rho_dlog(&gamma, &h_k, &p, &m, &ctx), p_pow[k]);
        x += Integer::from(pollard_rho_dlog(&gamma, &h_k, &p, &m, ctx)) * &p_pow[k];
        x %= Integer::from(&p_pow[*e as usize]);
        //println!("x: {}", x);
    }
    // println!("result for: {}^x = {} mod {}: {}", g.invert(m).unwrap(), h, m, x);
    x 
}

/// calculates the discrete logarithm: i.e given g, h and m, finds x such that g^x = h mod m, where m = p^e
/// Assumes 0 < g, h < m, and that the primes in the prime factorization of phi(m) (euler's totient) fits within a u64
fn discrete_log_prime_power_mod(p: &u64, e: &u32, m: &Integer, g: &Integer, h: &Integer) -> Option<(Integer, Integer)> {
    // println!("discrete log prime power mod on g = {}, h = {}, n = {} (which is {}^{})", g, h, m, p, e);
    let mut factors: Vec<(u64, u32)> = Vec::new();
    factors.extend(convert_factors_u64(prime_factorize(&Integer::from(p - 1))).unwrap());
    if *e != 1 {
        factors.push((*p, e - 1)); // n = p^(e-1) * (p - 1), so its prime factors are the prime factors of p-1 and p^(e-1)
    }
    let phi_m_factors = &factors;

    let phi_m = product(phi_m_factors);
    //println!("phi({}) = {}", m, phi_m);

    let ord_g = find_order(&m, &phi_m,  &g, phi_m_factors);

    if g == h {
        return Some((Integer::ONE.clone(), ord_g));
    }
    
    // Check if the order of h divides that of g, otherwise a solution does not exist
    if !ord_g.is_divisible(&find_order(&m, &phi_m, &h, &phi_m_factors)) {
        return None;
    }

    // println!("order of {} mod {}^{}: {}", g, p, e, ord_g);
    // If we reached here, a solution exists.
    // Break down the Discrete log problem to groups of order p^e because we love cyclic groups
    // Then merge the results using Chinese Remainder Theorem

    factors.clear();
    //println!("factorizing {}", ord_g);
    factors.extend(convert_factors_u64(prime_factorize(&ord_g)).unwrap());
    //println!("prime factors of {}: {:?}", ord_g, factors);
    let ord_g_factors = &factors;
    let mut ctx = Context::new(m.clone());
    let mut value: Integer = Integer::ZERO.clone();
    let mut ord_value = Integer::ONE.clone();
    
    let mut m_i = Integer::new();
    let mut g_i = Integer::new();
    let mut h_i = Integer::new();
    for (p, e) in ord_g_factors {
        // here, p is a prime factor of the order of g and e is its exponent.
        m_i.assign(p);
        m_i.pow_assign(e);
        let mut exponent = ord_g.clone();
        exponent.div_exact_mut(&m_i);
        g_i.assign(g.pow_mod_ref(&exponent, &m).unwrap());
        h_i.assign(h.pow_mod_ref(&exponent, &m).unwrap());
        (value, ord_value) = match chinese_remainder_theorem(&value, &ord_value,
        &discrete_log_prime_power_order(&p, &e, &m, &mut ctx, g_i.clone(), &h_i), &m_i) {
            Some((val1, val2)) => (val1, val2),
            None => return None,
        };
        // println!("prime pow mod result so far: {}^{}, value: {}, order: {}", p, e, value, ord_value);
    }
    // println!("prime pow mod full result: {}^{} = {} mod {}, order {}", g, value, h, m, ord_value);
    Some((value, ord_value))
}

/// calculates the discrete logarithm: i.e given g, h and n, finds x such that g^x = h mod n.
/// It also returns the period: i.e the order of g mod n.
/// Assumptions: g, h, n positive integers, and that the primes in the prime factorization of
/// phi(n) (euler's totient) fits within a u64.
/// (the algorithm would take forever if one of them is greater than a u64 either way)
pub fn discrete_log(mut g: Integer, mut h: Integer, mut n: Integer) -> Option<(Integer, Integer)> {
    // try to convert g, h into elements of (Z/nZ)*
    g %= &n;
    h %= &n;
    if g.is_zero() && h.is_zero() {
        return Some((Integer::ONE.clone(), Integer::ONE.clone()));
    }
    if g.is_zero() {
        return None;
    }

    let mut prev_a = Integer::ONE.clone();
    let mut prev_gcd = Integer::ONE.clone();
    let mut new_a = g.clone();
    let mut new_gcd = g.clone().gcd(&n);
    let mut k = Integer::ZERO.clone();

    while prev_a != h && prev_gcd < new_gcd {
        k += 1;
        prev_a.assign(&new_a);
        prev_gcd.assign(&new_gcd);
        new_a *= &g;
        new_a %= &n;
        new_gcd.assign(new_a.gcd_ref(&n));
    }

    if prev_gcd != h.clone().gcd(&n) {
        return None;
    }
    if prev_a == h {
        let factors = convert_factors_u64(prime_factorize(&n)).unwrap();
        let ord_g = find_order(&n, &product(&factors), &g, &factors);
        return Some((k, ord_g));
    }
    n.div_exact_mut(&prev_gcd);
    h.div_exact_mut(&prev_gcd);
    prev_a.div_exact_mut(&prev_gcd);
    h *= prev_a.invert(&n).unwrap();
    g %= &n;
    h %= &n;

    // println!("discrete log on g = {}, h = {}, n = {}", g, h, n);
    // handle n has a factor of a power of 2 case before starting.
    let mut value = Integer::ZERO.clone();
    let mut ord_value = Integer::ONE.clone(); 
    
    // removes the even factor
    if n.is_even() {
        let two_exponent: u32 = n.find_one(0).unwrap();
        n.shr_assign(two_exponent);
        let mut temp_g = Integer::new();
        temp_g.assign(g.keep_bits_ref(two_exponent));
        // println!("n is even g {}", temp_g);
        value = match discrete_log_mod_2pow(&temp_g, 
        &Integer::from(h.keep_bits_ref(two_exponent)), two_exponent) {
            Some(val) => val,
            None => return None,
        };
        ord_value = Integer::ONE.clone();
        while temp_g != *Integer::ONE {
            temp_g.square_mut();
            temp_g.keep_bits_mut(two_exponent);
            ord_value *= 2;
        }
        value %= &ord_value;
        // println!("n is even value: {}, order: {}", value, ord_value);
    }

    let factors: Vec<(u64, u32)> = convert_factors_u64(prime_factorize(&n)).unwrap();
    //println!("factors of n: {:?}", factors);
    let mut m = Integer::new();
    
    for (p, e) in factors {
        m.assign(p);
        m.pow_assign(e - 1);
        m *= &p;

        let (result, ord_result) = match discrete_log_prime_power_mod(&p, &e, &m,
            &Integer::from(&g % &m), &Integer::from(&h % &m)) {
            Some((val1, val2)) => (val1, val2),
            None => return None,
        };
        (value, ord_value) = match chinese_remainder_theorem(&value, &ord_value, &result, &ord_result) {
            Some((val1, val2)) => (val1, val2),
            None => return None,
        };
        // println!("discrete log value so far: {}, order: {}", value, ord_value);
    }

    Some((value + k, ord_value))
}

/* 
fn main() {

    let g = Integer::from_str("499708073396168950693728257752714787588413203102257224346183879662239238936923357893984894").unwrap();
    let h = Integer::from_str("246725564227816607288585072764452898081249591823425639121874856697723261762837949231721064503763409552653266689983015581478453440466668565640391940961688111774").unwrap();
    let n = Integer::from_str("4845995082164686315671847052869228890255646526352817824850321454857144343594736523147049704265172293757104621166506325638735578826350643078012092472255499422087").unwrap();
    println!("ans: {}", discrete_log(g, h, n).unwrap());
    /*
    let bits = 300; // number of bits
    let trials = 1000;
    let mut testcase: Vec<(Integer, Integer, Integer)> = Vec::with_capacity(trials);
    let mut rand = RandState::new();
    for _ in 0..trials {
        let mut g = Integer::from(Integer::random_bits(bits, &mut rand));
        let n = generate_smooth_integer(bits, &mut rand);
        g %= &n;
        let h: Integer = g.clone().pow_mod(&Integer::from(Integer::random_bits(bits, &mut rand)), &n).unwrap();
        testcase.push((g, h, n));
    }
    
    let mut failed = 0;
    println!("starting tests!");
    
    let total_start = Instant::now();

    for (g, h, n) in testcase {
        let start_time = Instant::now();
        println!("g = {}, h = {}, n = {}", g, h, n);
        let res = match discrete_log(g.clone(), h.clone(), n.clone()) {
            Some(val) => val,
            None => Integer::NEG_ONE.clone(),
        };
        let elapsed = start_time.elapsed();
        if res == *Integer::NEG_ONE || g.clone().pow_mod(&res, &n).unwrap() != h {
            println!("failed... g = {}, h = {}, n = {}, result = {}", g, h, n, res);
            break;
        }
        failed += 1;
        println!("Passed! Progress: {}, Time taken: {:?}", failed, elapsed);
    }
    let total_elapsed = total_start.elapsed();

    println!("it took {:?} to calculate the discrete log of {} testcases, each of size approximately {} bits", total_elapsed, trials, bits);
    // println!("Of all the testcases, {} of them failed...", failed);
    */

}*/